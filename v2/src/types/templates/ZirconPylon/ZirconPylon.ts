// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  EthereumCall,
  EthereumEvent,
  SmartContract,
  EthereumValue,
  JSONValue,
  TypedMap,
  Entity,
  EthereumTuple,
  Bytes,
  Address,
  BigInt,
  CallResult
} from "@graphprotocol/graph-ts";

export class Burn extends EthereumEvent {
  get params(): Burn__Params {
    return new Burn__Params(this);
  }
}

export class Burn__Params {
  _event: Burn;

  constructor(event: Burn) {
    this._event = event;
  }

  get sender(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get aIn0(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }

  get isAnchor(): boolean {
    return this._event.parameters[2].value.toBoolean();
  }
}

export class BurnAsync extends EthereumEvent {
  get params(): BurnAsync__Params {
    return new BurnAsync__Params(this);
  }
}

export class BurnAsync__Params {
  _event: BurnAsync;

  constructor(event: BurnAsync) {
    this._event = event;
  }

  get sender(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get aIn0(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }

  get aIn1(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }
}

export class Excess extends EthereumEvent {
  get params(): Excess__Params {
    return new Excess__Params(this);
  }
}

export class Excess__Params {
  _event: Excess;

  constructor(event: Excess) {
    this._event = event;
  }

  get aIn0(): BigInt {
    return this._event.parameters[0].value.toBigInt();
  }

  get isAnchor(): boolean {
    return this._event.parameters[1].value.toBoolean();
  }
}

export class MintAsync extends EthereumEvent {
  get params(): MintAsync__Params {
    return new MintAsync__Params(this);
  }
}

export class MintAsync__Params {
  _event: MintAsync;

  constructor(event: MintAsync) {
    this._event = event;
  }

  get sender(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get aIn0(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }

  get aIn1(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }
}

export class MintAsync100 extends EthereumEvent {
  get params(): MintAsync100__Params {
    return new MintAsync100__Params(this);
  }
}

export class MintAsync100__Params {
  _event: MintAsync100;

  constructor(event: MintAsync100) {
    this._event = event;
  }

  get sender(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get aIn0(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }

  get isAnchor(): boolean {
    return this._event.parameters[2].value.toBoolean();
  }
}

export class MintSync extends EthereumEvent {
  get params(): MintSync__Params {
    return new MintSync__Params(this);
  }
}

export class MintSync__Params {
  _event: MintSync;

  constructor(event: MintSync) {
    this._event = event;
  }

  get sender(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get aIn0(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }

  get isAnchor(): boolean {
    return this._event.parameters[2].value.toBoolean();
  }
}

export class PylonSync extends EthereumEvent {
  get params(): PylonSync__Params {
    return new PylonSync__Params(this);
  }
}

export class PylonSync__Params {
  _event: PylonSync;

  constructor(event: PylonSync) {
    this._event = event;
  }

  get _vab(): BigInt {
    return this._event.parameters[0].value.toBigInt();
  }

  get _vfb(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }

  get _gamma(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }
}

export class PylonUpdate extends EthereumEvent {
  get params(): PylonUpdate__Params {
    return new PylonUpdate__Params(this);
  }
}

export class PylonUpdate__Params {
  _event: PylonUpdate;

  constructor(event: PylonUpdate) {
    this._event = event;
  }

  get _reserve0(): BigInt {
    return this._event.parameters[0].value.toBigInt();
  }

  get _reserve1(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }
}

export class ZirconPylon__burnAsyncResult {
  value0: BigInt;
  value1: BigInt;

  constructor(value0: BigInt, value1: BigInt) {
    this.value0 = value0;
    this.value1 = value1;
  }

  toMap(): TypedMap<string, EthereumValue> {
    let map = new TypedMap<string, EthereumValue>();
    map.set("value0", EthereumValue.fromUnsignedBigInt(this.value0));
    map.set("value1", EthereumValue.fromUnsignedBigInt(this.value1));
    return map;
  }
}

export class ZirconPylon__getSyncReservesResult {
  value0: BigInt;
  value1: BigInt;
  value2: BigInt;

  constructor(value0: BigInt, value1: BigInt, value2: BigInt) {
    this.value0 = value0;
    this.value1 = value1;
    this.value2 = value2;
  }

  toMap(): TypedMap<string, EthereumValue> {
    let map = new TypedMap<string, EthereumValue>();
    map.set("value0", EthereumValue.fromUnsignedBigInt(this.value0));
    map.set("value1", EthereumValue.fromUnsignedBigInt(this.value1));
    map.set("value2", EthereumValue.fromUnsignedBigInt(this.value2));
    return map;
  }
}

export class ZirconPylon__initPylonResult {
  value0: BigInt;
  value1: BigInt;

  constructor(value0: BigInt, value1: BigInt) {
    this.value0 = value0;
    this.value1 = value1;
  }

  toMap(): TypedMap<string, EthereumValue> {
    let map = new TypedMap<string, EthereumValue>();
    map.set("value0", EthereumValue.fromUnsignedBigInt(this.value0));
    map.set("value1", EthereumValue.fromUnsignedBigInt(this.value1));
    return map;
  }
}

export class ZirconPylon__pylonTokenResult {
  value0: Address;
  value1: Address;

  constructor(value0: Address, value1: Address) {
    this.value0 = value0;
    this.value1 = value1;
  }

  toMap(): TypedMap<string, EthereumValue> {
    let map = new TypedMap<string, EthereumValue>();
    map.set("value0", EthereumValue.fromAddress(this.value0));
    map.set("value1", EthereumValue.fromAddress(this.value1));
    return map;
  }
}

export class ZirconPylon extends SmartContract {
  static bind(address: Address): ZirconPylon {
    return new ZirconPylon("ZirconPylon", address);
  }

  MINIMUM_LIQUIDITY(): BigInt {
    let result = super.call("MINIMUM_LIQUIDITY", []);

    return result[0].toBigInt();
  }

  try_MINIMUM_LIQUIDITY(): CallResult<BigInt> {
    let result = super.tryCall("MINIMUM_LIQUIDITY", []);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toBigInt());
  }

  anchorPoolTokenAddress(): Address {
    let result = super.call("anchorPoolTokenAddress", []);

    return result[0].toAddress();
  }

  try_anchorPoolTokenAddress(): CallResult<Address> {
    let result = super.tryCall("anchorPoolTokenAddress", []);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toAddress());
  }

  burn(_to: Address, _isAnchor: boolean): BigInt {
    let result = super.call("burn", [
      EthereumValue.fromAddress(_to),
      EthereumValue.fromBoolean(_isAnchor)
    ]);

    return result[0].toBigInt();
  }

  try_burn(_to: Address, _isAnchor: boolean): CallResult<BigInt> {
    let result = super.tryCall("burn", [
      EthereumValue.fromAddress(_to),
      EthereumValue.fromBoolean(_isAnchor)
    ]);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toBigInt());
  }

  burnAsync(_to: Address, _isAnchor: boolean): ZirconPylon__burnAsyncResult {
    let result = super.call("burnAsync", [
      EthereumValue.fromAddress(_to),
      EthereumValue.fromBoolean(_isAnchor)
    ]);

    return new ZirconPylon__burnAsyncResult(
      result[0].toBigInt(),
      result[1].toBigInt()
    );
  }

  try_burnAsync(
    _to: Address,
    _isAnchor: boolean
  ): CallResult<ZirconPylon__burnAsyncResult> {
    let result = super.tryCall("burnAsync", [
      EthereumValue.fromAddress(_to),
      EthereumValue.fromBoolean(_isAnchor)
    ]);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(
      new ZirconPylon__burnAsyncResult(value[0].toBigInt(), value[1].toBigInt())
    );
  }

  dynamicFeePercentage(): BigInt {
    let result = super.call("dynamicFeePercentage", []);

    return result[0].toBigInt();
  }

  try_dynamicFeePercentage(): CallResult<BigInt> {
    let result = super.tryCall("dynamicFeePercentage", []);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toBigInt());
  }

  factoryAddress(): Address {
    let result = super.call("factoryAddress", []);

    return result[0].toAddress();
  }

  try_factoryAddress(): CallResult<Address> {
    let result = super.tryCall("factoryAddress", []);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toAddress());
  }

  floatPoolTokenAddress(): Address {
    let result = super.call("floatPoolTokenAddress", []);

    return result[0].toAddress();
  }

  try_floatPoolTokenAddress(): CallResult<Address> {
    let result = super.tryCall("floatPoolTokenAddress", []);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toAddress());
  }

  gammaMulDecimals(): BigInt {
    let result = super.call("gammaMulDecimals", []);

    return result[0].toBigInt();
  }

  try_gammaMulDecimals(): CallResult<BigInt> {
    let result = super.tryCall("gammaMulDecimals", []);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toBigInt());
  }

  getSyncReserves(): ZirconPylon__getSyncReservesResult {
    let result = super.call("getSyncReserves", []);

    return new ZirconPylon__getSyncReservesResult(
      result[0].toBigInt(),
      result[1].toBigInt(),
      result[2].toBigInt()
    );
  }

  try_getSyncReserves(): CallResult<ZirconPylon__getSyncReservesResult> {
    let result = super.tryCall("getSyncReserves", []);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(
      new ZirconPylon__getSyncReservesResult(
        value[0].toBigInt(),
        value[1].toBigInt(),
        value[2].toBigInt()
      )
    );
  }

  initPylon(_to: Address): ZirconPylon__initPylonResult {
    let result = super.call("initPylon", [EthereumValue.fromAddress(_to)]);

    return new ZirconPylon__initPylonResult(
      result[0].toBigInt(),
      result[1].toBigInt()
    );
  }

  try_initPylon(_to: Address): CallResult<ZirconPylon__initPylonResult> {
    let result = super.tryCall("initPylon", [EthereumValue.fromAddress(_to)]);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(
      new ZirconPylon__initPylonResult(value[0].toBigInt(), value[1].toBigInt())
    );
  }

  initialized(): BigInt {
    let result = super.call("initialized", []);

    return result[0].toBigInt();
  }

  try_initialized(): CallResult<BigInt> {
    let result = super.tryCall("initialized", []);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toBigInt());
  }

  isFloatReserve0(): boolean {
    let result = super.call("isFloatReserve0", []);

    return result[0].toBoolean();
  }

  try_isFloatReserve0(): CallResult<boolean> {
    let result = super.tryCall("isFloatReserve0", []);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toBoolean());
  }

  lastK(): BigInt {
    let result = super.call("lastK", []);

    return result[0].toBigInt();
  }

  try_lastK(): CallResult<BigInt> {
    let result = super.tryCall("lastK", []);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toBigInt());
  }

  lastPoolTokens(): BigInt {
    let result = super.call("lastPoolTokens", []);

    return result[0].toBigInt();
  }

  try_lastPoolTokens(): CallResult<BigInt> {
    let result = super.tryCall("lastPoolTokens", []);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toBigInt());
  }

  maximumPercentageSync(): BigInt {
    let result = super.call("maximumPercentageSync", []);

    return result[0].toBigInt();
  }

  try_maximumPercentageSync(): CallResult<BigInt> {
    let result = super.tryCall("maximumPercentageSync", []);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toBigInt());
  }

  mintAsync(to: Address, shouldMintAnchor: boolean): BigInt {
    let result = super.call("mintAsync", [
      EthereumValue.fromAddress(to),
      EthereumValue.fromBoolean(shouldMintAnchor)
    ]);

    return result[0].toBigInt();
  }

  try_mintAsync(to: Address, shouldMintAnchor: boolean): CallResult<BigInt> {
    let result = super.tryCall("mintAsync", [
      EthereumValue.fromAddress(to),
      EthereumValue.fromBoolean(shouldMintAnchor)
    ]);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toBigInt());
  }

  mintAsync100(to: Address, isAnchor: boolean): BigInt {
    let result = super.call("mintAsync100", [
      EthereumValue.fromAddress(to),
      EthereumValue.fromBoolean(isAnchor)
    ]);

    return result[0].toBigInt();
  }

  try_mintAsync100(to: Address, isAnchor: boolean): CallResult<BigInt> {
    let result = super.tryCall("mintAsync100", [
      EthereumValue.fromAddress(to),
      EthereumValue.fromBoolean(isAnchor)
    ]);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toBigInt());
  }

  mintPoolTokens(_to: Address, isAnchor: boolean): BigInt {
    let result = super.call("mintPoolTokens", [
      EthereumValue.fromAddress(_to),
      EthereumValue.fromBoolean(isAnchor)
    ]);

    return result[0].toBigInt();
  }

  try_mintPoolTokens(_to: Address, isAnchor: boolean): CallResult<BigInt> {
    let result = super.tryCall("mintPoolTokens", [
      EthereumValue.fromAddress(_to),
      EthereumValue.fromBoolean(isAnchor)
    ]);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toBigInt());
  }

  pairAddress(): Address {
    let result = super.call("pairAddress", []);

    return result[0].toAddress();
  }

  try_pairAddress(): CallResult<Address> {
    let result = super.tryCall("pairAddress", []);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toAddress());
  }

  pairFactoryAddress(): Address {
    let result = super.call("pairFactoryAddress", []);

    return result[0].toAddress();
  }

  try_pairFactoryAddress(): CallResult<Address> {
    let result = super.tryCall("pairFactoryAddress", []);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toAddress());
  }

  pylonToken(): ZirconPylon__pylonTokenResult {
    let result = super.call("pylonToken", []);

    return new ZirconPylon__pylonTokenResult(
      result[0].toAddress(),
      result[1].toAddress()
    );
  }

  try_pylonToken(): CallResult<ZirconPylon__pylonTokenResult> {
    let result = super.tryCall("pylonToken", []);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(
      new ZirconPylon__pylonTokenResult(
        value[0].toAddress(),
        value[1].toAddress()
      )
    );
  }

  virtualAnchorBalance(): BigInt {
    let result = super.call("virtualAnchorBalance", []);

    return result[0].toBigInt();
  }

  try_virtualAnchorBalance(): CallResult<BigInt> {
    let result = super.tryCall("virtualAnchorBalance", []);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toBigInt());
  }

  virtualFloatBalance(): BigInt {
    let result = super.call("virtualFloatBalance", []);

    return result[0].toBigInt();
  }

  try_virtualFloatBalance(): CallResult<BigInt> {
    let result = super.tryCall("virtualFloatBalance", []);
    if (result.reverted) {
      return new CallResult();
    }
    let value = result.value;
    return CallResult.fromValue(value[0].toBigInt());
  }
}

export class ConstructorCall extends EthereumCall {
  get inputs(): ConstructorCall__Inputs {
    return new ConstructorCall__Inputs(this);
  }

  get outputs(): ConstructorCall__Outputs {
    return new ConstructorCall__Outputs(this);
  }
}

export class ConstructorCall__Inputs {
  _call: ConstructorCall;

  constructor(call: ConstructorCall) {
    this._call = call;
  }
}

export class ConstructorCall__Outputs {
  _call: ConstructorCall;

  constructor(call: ConstructorCall) {
    this._call = call;
  }
}

export class BurnCall extends EthereumCall {
  get inputs(): BurnCall__Inputs {
    return new BurnCall__Inputs(this);
  }

  get outputs(): BurnCall__Outputs {
    return new BurnCall__Outputs(this);
  }
}

export class BurnCall__Inputs {
  _call: BurnCall;

  constructor(call: BurnCall) {
    this._call = call;
  }

  get _to(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get _isAnchor(): boolean {
    return this._call.inputValues[1].value.toBoolean();
  }
}

export class BurnCall__Outputs {
  _call: BurnCall;

  constructor(call: BurnCall) {
    this._call = call;
  }

  get amount(): BigInt {
    return this._call.outputValues[0].value.toBigInt();
  }
}

export class BurnAsyncCall extends EthereumCall {
  get inputs(): BurnAsyncCall__Inputs {
    return new BurnAsyncCall__Inputs(this);
  }

  get outputs(): BurnAsyncCall__Outputs {
    return new BurnAsyncCall__Outputs(this);
  }
}

export class BurnAsyncCall__Inputs {
  _call: BurnAsyncCall;

  constructor(call: BurnAsyncCall) {
    this._call = call;
  }

  get _to(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get _isAnchor(): boolean {
    return this._call.inputValues[1].value.toBoolean();
  }
}

export class BurnAsyncCall__Outputs {
  _call: BurnAsyncCall;

  constructor(call: BurnAsyncCall) {
    this._call = call;
  }

  get amount0(): BigInt {
    return this._call.outputValues[0].value.toBigInt();
  }

  get amount1(): BigInt {
    return this._call.outputValues[1].value.toBigInt();
  }
}

export class InitPylonCall extends EthereumCall {
  get inputs(): InitPylonCall__Inputs {
    return new InitPylonCall__Inputs(this);
  }

  get outputs(): InitPylonCall__Outputs {
    return new InitPylonCall__Outputs(this);
  }
}

export class InitPylonCall__Inputs {
  _call: InitPylonCall;

  constructor(call: InitPylonCall) {
    this._call = call;
  }

  get _to(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class InitPylonCall__Outputs {
  _call: InitPylonCall;

  constructor(call: InitPylonCall) {
    this._call = call;
  }

  get floatLiquidity(): BigInt {
    return this._call.outputValues[0].value.toBigInt();
  }

  get anchorLiquidity(): BigInt {
    return this._call.outputValues[1].value.toBigInt();
  }
}

export class InitializeCall extends EthereumCall {
  get inputs(): InitializeCall__Inputs {
    return new InitializeCall__Inputs(this);
  }

  get outputs(): InitializeCall__Outputs {
    return new InitializeCall__Outputs(this);
  }
}

export class InitializeCall__Inputs {
  _call: InitializeCall;

  constructor(call: InitializeCall) {
    this._call = call;
  }

  get _floatPoolTokenAddress(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get _anchorPoolTokenAddress(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get _floatToken(): Address {
    return this._call.inputValues[2].value.toAddress();
  }

  get _anchorToken(): Address {
    return this._call.inputValues[3].value.toAddress();
  }

  get _pairAddress(): Address {
    return this._call.inputValues[4].value.toAddress();
  }

  get _pairFactoryAddress(): Address {
    return this._call.inputValues[5].value.toAddress();
  }
}

export class InitializeCall__Outputs {
  _call: InitializeCall;

  constructor(call: InitializeCall) {
    this._call = call;
  }
}

export class MintAsyncCall extends EthereumCall {
  get inputs(): MintAsyncCall__Inputs {
    return new MintAsyncCall__Inputs(this);
  }

  get outputs(): MintAsyncCall__Outputs {
    return new MintAsyncCall__Outputs(this);
  }
}

export class MintAsyncCall__Inputs {
  _call: MintAsyncCall;

  constructor(call: MintAsyncCall) {
    this._call = call;
  }

  get to(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get shouldMintAnchor(): boolean {
    return this._call.inputValues[1].value.toBoolean();
  }
}

export class MintAsyncCall__Outputs {
  _call: MintAsyncCall;

  constructor(call: MintAsyncCall) {
    this._call = call;
  }

  get liquidity(): BigInt {
    return this._call.outputValues[0].value.toBigInt();
  }
}

export class MintAsync100Call extends EthereumCall {
  get inputs(): MintAsync100Call__Inputs {
    return new MintAsync100Call__Inputs(this);
  }

  get outputs(): MintAsync100Call__Outputs {
    return new MintAsync100Call__Outputs(this);
  }
}

export class MintAsync100Call__Inputs {
  _call: MintAsync100Call;

  constructor(call: MintAsync100Call) {
    this._call = call;
  }

  get to(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get isAnchor(): boolean {
    return this._call.inputValues[1].value.toBoolean();
  }
}

export class MintAsync100Call__Outputs {
  _call: MintAsync100Call;

  constructor(call: MintAsync100Call) {
    this._call = call;
  }

  get liquidity(): BigInt {
    return this._call.outputValues[0].value.toBigInt();
  }
}

export class MintPoolTokensCall extends EthereumCall {
  get inputs(): MintPoolTokensCall__Inputs {
    return new MintPoolTokensCall__Inputs(this);
  }

  get outputs(): MintPoolTokensCall__Outputs {
    return new MintPoolTokensCall__Outputs(this);
  }
}

export class MintPoolTokensCall__Inputs {
  _call: MintPoolTokensCall;

  constructor(call: MintPoolTokensCall) {
    this._call = call;
  }

  get _to(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get isAnchor(): boolean {
    return this._call.inputValues[1].value.toBoolean();
  }
}

export class MintPoolTokensCall__Outputs {
  _call: MintPoolTokensCall;

  constructor(call: MintPoolTokensCall) {
    this._call = call;
  }

  get liquidity(): BigInt {
    return this._call.outputValues[0].value.toBigInt();
  }
}
